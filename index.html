<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Internet Radio Dial</title>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #000000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            position: relative;
        }
        .station-toggle {
            position: fixed;
            right: 16px;
            bottom: 16px;
            width: 48px;
            height: 48px;
            background: rgba(255, 107, 53, 0.5);
            border-radius: 50%;
            cursor: pointer;
            z-index: 3;
        }
        .station-toggle.active {
            background: rgba(153, 153, 153, 0.5);
        }
        .drift-toggle {
            position: fixed;
            right: 72px;
            bottom: 16px;
            width: 48px;
            height: 48px;
            background: rgba(153, 153, 153, 0.5);
            border-radius: 50%;
            cursor: pointer;
            z-index: 3;
        }
        .drift-toggle.active {
            background: rgba(255, 107, 53, 0.5); /* orange like position-dot */
        }
        .station-panel {
            position: fixed;
            right: 16px;
            bottom: 72px;
            width: 260px;
            max-height: 50vh;
            overflow: auto;
            background: rgba(255,255,255,0.98);
            color: #111;
            border-radius: 8px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.12);
            padding: 12px 14px;
            display: none;
            z-index: 3;
            font-size: 14px;
            letter-spacing: 0.5px;
        }
        .station-panel.open { display: block; }
        .station-panel ul { list-style: none; margin: 0; padding: 0; }
        .station-panel li { padding: 6px 0; border-bottom: 1px solid #eee; }
        .station-panel li:last-child { border-bottom: none; }
        .prism-background {
            position: fixed;
            inset: 0;
            z-index: 0;
            pointer-events: none;
        }
        
        .prism-background canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            display: block;
        }
        
        @keyframes prismShift {
            0%, 100% { 
                transform: scale(1) rotate(0deg);
                filter: hue-rotate(0deg) brightness(1) saturate(1);
            }
            20% { 
                transform: scale(1.02) rotate(0.5deg);
                filter: hue-rotate(72deg) brightness(1.05) saturate(1.2);
            }
            40% { 
                transform: scale(1.04) rotate(0deg);
                filter: hue-rotate(144deg) brightness(1.1) saturate(1.4);
            }
            60% { 
                transform: scale(1.02) rotate(-0.5deg);
                filter: hue-rotate(216deg) brightness(1.05) saturate(1.2);
            }
            80% { 
                transform: scale(1.01) rotate(0.2deg);
                filter: hue-rotate(288deg) brightness(1.02) saturate(1.1);
            }
        }
        .container {
            position: relative;
            width: 400px;
            height: 400px;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
            flex-direction: column;
            gap: 30px;
        }
        .knob {
            position: relative;
            width: 400px;
            height: 400px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.10);
            backdrop-filter: blur(22px) saturate(1.15) contrast(1.03) brightness(1.06);
            -webkit-backdrop-filter: blur(22px) saturate(1.15) contrast(1.03) brightness(1.06);
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 
                0 8px 32px rgba(0,0,0,0.4),
                0 0 0 1px rgba(255, 255, 255, 0.2),
                inset 0 2px 4px rgba(255, 255, 255, 0.5),
                inset 0 -2px 4px rgba(0, 0, 0, 0.1);
            cursor: grab;
            user-select: none;
            transform: rotate(0deg);
            will-change: transform;
            overflow: hidden;
            --angle: 0deg;
        }
        .knob:active { cursor: grabbing; }
        .knob::before {
            content: '';
            position: absolute;
            inset: -10%;
            border-radius: 50%;
            pointer-events: none;
            background: radial-gradient(120% 120% at 30% 25%, rgba(255,255,255,0.18), rgba(255,255,255,0.06) 40%, transparent 65%);
            filter: blur(8px);
            mix-blend-mode: screen;
        }
        .knob::after { display: none; }

        /* WebGL refraction overlay inside the knob */
        .glass-overlay {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            display: block;
            pointer-events: none;
            z-index: 1;
        }
        .position-dot {
            position: absolute;
            top: 50%; left: 50%;
            width: 16px; height: 16px;
            background: #ff6b35;
            border-radius: 50%;
            transform: translate(-50%, -50%) translateY(-140px);
            box-shadow: 
                0 0 12px rgba(255,107,53,0.8), 
                inset 0 1px 2px rgba(255,255,255,0.5),
                0 0 20px rgba(255,107,53,0.4);
            z-index: 10;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .status {
            position: absolute;
            bottom: -60px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 14px;
            color: #ffffff;
            text-align: center;
            font-weight: 300;
            letter-spacing: 0.5px;
        }
        
        /* Mobile-only improvements - desktop remains unchanged */
        @media (max-width: 768px) {
            .station-toggle, .drift-toggle {
                width: 56px;
                height: 56px;
                bottom: 20px;
            }
            .station-toggle {
                right: 20px;
            }
            .drift-toggle {
                right: 90px;
            }
            .station-panel {
                right: 20px;
                bottom: 84px;
                width: calc(100vw - 40px);
                max-width: 300px;
            }
        }
        
        @media (max-width: 480px) {
            .station-panel {
                width: calc(100vw - 20px);
                right: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="prism-background" aria-hidden="true"></div>
    <div class="container">
        <div class="knob" id="knob">
            <div class="position-dot" id="positionDot"></div>
            <canvas class="glass-overlay" id="glassOverlay" aria-hidden="true"></canvas>
        </div>
        <div class="status" id="status">Click to start audio</div>
    </div>
    <div class="station-toggle" id="stationToggle" aria-label="Show stations" title="Stations"></div>
    <div class="station-panel" id="stationPanel" aria-hidden="true">
        <ul id="stationList"></ul>
    </div>
    <div class="drift-toggle" id="driftToggle" aria-label="Toggle drift" title="Drift"></div>
    <script>
    // Raw WebGL Prism Background (no dependencies)
    class PrismBackground {
        constructor(container, options = {}) {
            this.container = container;
            this.canvas = null;
            this.gl = null;
            this.program = null;
            this.raf = 0;
            this.startTime = performance.now();
            
            // Prism parameters
            this.height = options.height || 3.5;
            this.baseWidth = options.baseWidth || 5.5;
            this.glow = options.glow || 1;
            this.noise = options.noise || 0.5;
            this.scale = options.scale || 3.6;
            this.hueShift = options.hueShift || 0;
            this.colorFrequency = options.colorFrequency || 1;
            this.bloom = options.bloom || 1;
            this.timeScale = options.timeScale || 0.5;
            
            this.init();
        }
        
        init() {
            console.log('PrismBackground init called - using raw WebGL');
            
            // Create canvas
            this.canvas = document.createElement('canvas');
            this.canvas.style.position = 'absolute';
            this.canvas.style.inset = '0';
            this.canvas.style.width = '100%';
            this.canvas.style.height = '100%';
            this.canvas.style.display = 'block';
            
            this.container.appendChild(this.canvas);
            
            // Get WebGL context
            this.gl = this.canvas.getContext('webgl', { 
                alpha: true, 
                antialias: false,
                powerPreference: 'low-power'
            });
            
            if (!this.gl) {
                console.warn('WebGL not supported, falling back to CSS background');
                this.container.style.background = 'linear-gradient(45deg, rgba(255,0,150,0.03) 0%, rgba(0,255,255,0.02) 50%, rgba(255,255,0,0.03) 100%)';
                return;
            }
            
            console.log('WebGL context created successfully');
            
            this.gl.disable(this.gl.DEPTH_TEST);
            this.gl.disable(this.gl.CULL_FACE);
            this.gl.enable(this.gl.BLEND);
            this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
            
            this.setupShaders();
            this.setupGeometry();
            this.resize();
            this.startRender();
            
            window.addEventListener('resize', () => this.resize());
        }
        
        createShader(type, source) {
            const shader = this.gl.createShader(type);
            this.gl.shaderSource(shader, source);
            this.gl.compileShader(shader);
            
            if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', this.gl.getShaderInfoLog(shader));
                this.gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }
        
        setupShaders() {
            const vertexSource = `
                attribute vec2 a_position;
                void main() {
                    gl_Position = vec4(a_position, 0.0, 1.0);
                }
            `;
            
            const fragmentSource = `
                precision highp float;
                uniform vec2 u_resolution;
                uniform float u_time;
                uniform float u_height;
                uniform float u_baseHalf;
                uniform mat3 u_rot;
                uniform float u_glow;
                uniform float u_noise;
                uniform float u_scale;
                uniform float u_colorFreq;
                uniform float u_bloom;
                uniform float u_centerShift;
                uniform float u_invBaseHalf;
                uniform float u_invHeight;
                uniform float u_minAxis;
                uniform float u_pxScale;
                uniform float u_timeScale;

                vec4 tanh4(vec4 x) {
                    vec4 e2x = exp(2.0*x);
                    return (e2x - 1.0) / (e2x + 1.0);
                }

                float rand(vec2 co) {
                    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453123);
                }

                float sdOctaAnisoInv(vec3 p) {
                    vec3 q = vec3(abs(p.x) * u_invBaseHalf, abs(p.y) * u_invHeight, abs(p.z) * u_invBaseHalf);
                    float m = q.x + q.y + q.z - 1.0;
                    return m * u_minAxis * 0.5773502691896258;
                }

                float sdPyramidUpInv(vec3 p) {
                    float oct = sdOctaAnisoInv(p);
                    float halfSpace = -p.y;
                    return max(oct, halfSpace);
                }

                mat3 hueRotation(float a) {
                    float c = cos(a), s = sin(a);
                    mat3 W = mat3(
                        0.299, 0.587, 0.114,
                        0.299, 0.587, 0.114,
                        0.299, 0.587, 0.114
                    );
                    mat3 U = mat3(
                        0.701, -0.587, -0.114,
                        -0.299, 0.413, -0.114,
                        -0.300, -0.588, 0.886
                    );
                    mat3 V = mat3(
                        0.168, -0.331, 0.500,
                        0.328, 0.035, -0.500,
                        -0.497, 0.296, 0.201
                    );
                    return W + U * c + V * s;
                }

                void main() {
                    vec2 f = (gl_FragCoord.xy - 0.5 * u_resolution.xy) * u_pxScale;
                    float z = 5.0;
                    float d = 0.0;
                    vec3 p;
                    vec4 o = vec4(0.0);
                    float centerShift = u_centerShift;
                    float cf = u_colorFreq;

                    // Ultra-stable wobble matrix - no judder
                    mat2 wob = mat2(1.0);
                    float t = u_time * u_timeScale * 0.1; // Much slower
                    float c0 = cos(t * 0.05);
                    float c1 = sin(t * 0.03);
                    wob = mat2(c0, -c1, c1, c0);

                    const int STEPS = 50;
                    for (int i = 0; i < STEPS; i++) {
                        p = vec3(f, z);
                        p.xz = p.xz * wob;
                        p = u_rot * p;
                        vec3 q = p;
                        q.y += centerShift;
                        d = 0.1 + 0.2 * abs(sdPyramidUpInv(q));
                        z -= d;
                        
                        // Much more prominent prism with visible orange flares
                        vec4 colors = vec4(0.0);
                        float phase = (p.y + z) * cf;
                        float intensity = 1.2;  // Much higher intensity
                        float baseGray = 0.25;   // Brighter base
                        
                        float grayValue = sin(phase) * intensity + baseGray;
                        
                        // Very strong white highlights
                        float whiteHighlight = max(0.0, sin(phase * 2.0) - 0.4) * 2.0;
                        grayValue += whiteHighlight;
                        
                        // More frequent and visible orange flares
                        float orangeFlare = max(0.0, sin(phase * 0.5 + p.x * 0.2) - 0.7) * 3.0;
                        
                        colors.r = grayValue + orangeFlare * 1.2;      // Strong orange in red
                        colors.g = grayValue * 0.95 + orangeFlare * 0.6; // More orange in green
                        colors.b = grayValue * 1.02 + orangeFlare * 0.1; // Slight orange tint in blue
                        colors.a = 1.0;
                        
                        o += colors / d;
                    }

                    o = tanh4(o * o * (u_glow * u_bloom) / 1e5);

                    vec3 col = o.rgb;
                    
                    // Static grain based on position only - no judder
                    float n1 = rand(gl_FragCoord.xy);
                    float n2 = rand(gl_FragCoord.xy * 2.17); // Different prime-like multiplier
                    float n3 = rand(gl_FragCoord.xy * 0.43);
                    
                    float grain = (n1 - 0.5) * 0.15 + (n2 - 0.5) * 0.08 + (n3 - 0.5) * 0.05;
                    col += grain * u_noise;
                    col = clamp(col, 0.0, 1.0);

                    // Enhance contrast and brightness
                    col = pow(col, vec3(0.85)); // Slightly brighter gamma
                    col *= 1.3; // Boost overall brightness
                    col = clamp(col, 0.0, 1.0);
                    
                    gl_FragColor = vec4(col, 0.9);
                }
            `;
            
            const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexSource);
            const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentSource);
            
            if (!vertexShader || !fragmentShader) {
                console.error('Failed to create shaders');
                return;
            }
            
            this.program = this.gl.createProgram();
            this.gl.attachShader(this.program, vertexShader);
            this.gl.attachShader(this.program, fragmentShader);
            this.gl.linkProgram(this.program);
            
            if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {
                console.error('Shader program failed to link:', this.gl.getProgramInfoLog(this.program));
                return;
            }
            
            this.gl.useProgram(this.program);
            
            // Get uniform locations
            this.uniforms = {
                u_resolution: this.gl.getUniformLocation(this.program, 'u_resolution'),
                u_time: this.gl.getUniformLocation(this.program, 'u_time'),
                u_height: this.gl.getUniformLocation(this.program, 'u_height'),
                u_baseHalf: this.gl.getUniformLocation(this.program, 'u_baseHalf'),
                u_rot: this.gl.getUniformLocation(this.program, 'u_rot'),
                u_glow: this.gl.getUniformLocation(this.program, 'u_glow'),
                u_noise: this.gl.getUniformLocation(this.program, 'u_noise'),
                u_scale: this.gl.getUniformLocation(this.program, 'u_scale'),
                u_colorFreq: this.gl.getUniformLocation(this.program, 'u_colorFreq'),
                u_bloom: this.gl.getUniformLocation(this.program, 'u_bloom'),
                u_centerShift: this.gl.getUniformLocation(this.program, 'u_centerShift'),
                u_invBaseHalf: this.gl.getUniformLocation(this.program, 'u_invBaseHalf'),
                u_invHeight: this.gl.getUniformLocation(this.program, 'u_invHeight'),
                u_minAxis: this.gl.getUniformLocation(this.program, 'u_minAxis'),
                u_pxScale: this.gl.getUniformLocation(this.program, 'u_pxScale'),
                u_timeScale: this.gl.getUniformLocation(this.program, 'u_timeScale')
            };
            
            // Set static uniforms
            const H = Math.max(0.001, this.height);
            const BASE_HALF = Math.max(0.001, this.baseWidth) * 0.5;
            
            this.gl.uniform1f(this.uniforms.u_height, H);
            this.gl.uniform1f(this.uniforms.u_baseHalf, BASE_HALF);
            this.gl.uniform1f(this.uniforms.u_glow, Math.max(0.0, this.glow));
            this.gl.uniform1f(this.uniforms.u_noise, Math.max(0.0, this.noise));
            this.gl.uniform1f(this.uniforms.u_scale, Math.max(0.001, this.scale));
            this.gl.uniform1f(this.uniforms.u_colorFreq, Math.max(0.0, this.colorFrequency));
            this.gl.uniform1f(this.uniforms.u_bloom, Math.max(0.0, this.bloom));
            this.gl.uniform1f(this.uniforms.u_centerShift, H * 0.25);
            this.gl.uniform1f(this.uniforms.u_invBaseHalf, 1 / BASE_HALF);
            this.gl.uniform1f(this.uniforms.u_invHeight, 1 / H);
            this.gl.uniform1f(this.uniforms.u_minAxis, Math.min(BASE_HALF, H));
            this.gl.uniform1f(this.uniforms.u_timeScale, Math.max(0, this.timeScale));
            
            console.log('Shaders setup complete');
        }
        
        setupGeometry() {
            // Create a triangle that covers the entire screen
            const vertices = new Float32Array([
                -1, -1,
                 3, -1,
                -1,  3
            ]);
            
            const buffer = this.gl.createBuffer();
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
            this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);
            
            const positionLocation = this.gl.getAttribLocation(this.program, 'a_position');
            this.gl.enableVertexAttribArray(positionLocation);
            this.gl.vertexAttribPointer(positionLocation, 2, this.gl.FLOAT, false, 0, 0);
            
            console.log('Geometry setup complete');
        }
        
        resize() {
            const w = this.container.clientWidth || 1;
            const h = this.container.clientHeight || 1;
            const dpr = Math.min(2, window.devicePixelRatio || 1);
            
            this.canvas.width = w * dpr;
            this.canvas.height = h * dpr;
            this.canvas.style.width = w + 'px';
            this.canvas.style.height = h + 'px';
            
            if (this.gl && this.uniforms) {
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                this.gl.uniform2f(this.uniforms.u_resolution, this.canvas.width, this.canvas.height);
                this.gl.uniform1f(this.uniforms.u_pxScale, 1 / ((this.canvas.height || 1) * 0.1 * this.scale));
            }
        }
        
        setMat3FromEuler(yaw, pitch, roll) {
            const cy = Math.cos(yaw), sy = Math.sin(yaw);
            const cx = Math.cos(pitch), sx = Math.sin(pitch);
            const cz = Math.cos(roll), sz = Math.sin(roll);
            
            return [
                cy * cz + sy * sx * sz, cx * sz, -sy * cz + cy * sx * sz,
                -cy * sz + sy * sx * cz, cx * cz, sy * sz + cy * sx * cz,
                sy * cx, -sx, cy * cx
            ];
        }
        
        startRender() {
            if (!this.gl || !this.program) {
                console.error('WebGL not ready for rendering');
                return;
            }
            
            console.log('Starting render loop');
            
            // Random rotation parameters
            const rnd = () => Math.random();
            const wX = (0.3 + rnd() * 0.6);
            const wY = (0.2 + rnd() * 0.7);
            const wZ = (0.1 + rnd() * 0.5);
            const phX = rnd() * Math.PI * 2;
            const phZ = rnd() * Math.PI * 2;
            
            const render = (t) => {
                const time = (t - this.startTime) * 0.001;
                
                this.gl.uniform1f(this.uniforms.u_time, time);
                
                // Rotate the prism
                const tScaled = time * this.timeScale;
                const yaw = tScaled * wY;
                const pitch = Math.sin(tScaled * wX + phX) * 0.6;
                const roll = Math.sin(tScaled * wZ + phZ) * 0.5;
                
                const rotMatrix = this.setMat3FromEuler(yaw, pitch, roll);
                this.gl.uniformMatrix3fv(this.uniforms.u_rot, false, rotMatrix);
                
                this.gl.clear(this.gl.COLOR_BUFFER_BIT);
                this.gl.drawArrays(this.gl.TRIANGLES, 0, 3);
                
                this.raf = requestAnimationFrame(render);
            };
            
            this.raf = requestAnimationFrame(render);
        }
        
        destroy() {
            if (this.raf) {
                cancelAnimationFrame(this.raf);
                this.raf = 0;
            }
            if (this.canvas && this.canvas.parentElement) {
                this.canvas.parentElement.removeChild(this.canvas);
            }
        }
    }

    class AudioEngine {
        constructor() {
            this.audioContext = null;
            this.staticSource = null;
            this.staticGain = null;
            this.staticFilter = null;
            this.masterCompressor = null;
            this.isInitialized = false;
            this.isPlaying = false;
            this.staticVolume = 0.15;
            this.streamManager = null;
        }
        
        init() {
            try {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                console.log('Audio context created, state:', this.audioContext.state);
                this.streamManager = new StreamManager();
                this.isInitialized = true;
                
                // Mobile browsers often start in 'suspended' state
                if (this.audioContext.state === 'suspended') {
                    console.log('Audio context suspended, will resume on user interaction');
                }
                
            } catch (error) {
                console.error('Failed to initialize audio:', error);
            }
        }
        
        setupStaticNoise() {
            console.log('Setting up static noise, sample rate:', this.audioContext.sampleRate);
            const bufferSize = this.audioContext.sampleRate * 2;
            const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
            const output = buffer.getChannelData(0);
            
            for (let i = 0; i < bufferSize; i++) {
                output[i] = (Math.random() * 2 - 1) * 0.25;
            }
            
            this.staticSource = this.audioContext.createBufferSource();
            this.staticSource.buffer = buffer;
            this.staticSource.loop = true;
            console.log('Static buffer created, size:', bufferSize);
            
            // Static processing chain: source -> lowpass -> gain -> master compressor -> destination
            this.staticFilter = this.audioContext.createBiquadFilter();
            this.staticFilter.type = 'lowpass';
            this.staticFilter.frequency.setValueAtTime(12000, this.audioContext.currentTime);
            this.staticFilter.Q.value = 0.7;

            this.staticGain = this.audioContext.createGain();
            this.staticGain.gain.setValueAtTime(this.staticVolume, this.audioContext.currentTime);

            this.masterCompressor = this.audioContext.createDynamicsCompressor();
            this.masterCompressor.threshold.setValueAtTime(-14, this.audioContext.currentTime);
            this.masterCompressor.knee.setValueAtTime(18, this.audioContext.currentTime);
            this.masterCompressor.ratio.setValueAtTime(3, this.audioContext.currentTime);
            this.masterCompressor.attack.setValueAtTime(0.003, this.audioContext.currentTime);
            this.masterCompressor.release.setValueAtTime(0.25, this.audioContext.currentTime);

            this.staticSource.connect(this.staticFilter);
            this.staticFilter.connect(this.staticGain);
            this.staticGain.connect(this.masterCompressor);
            this.masterCompressor.connect(this.audioContext.destination);
            
            // Initialize StreamManager with static gain reference
            if (this.streamManager) {
                this.streamManager.init(this.audioContext, this.staticGain, this.masterCompressor, this.staticFilter);
            }
        }
        
        getTuningState() {
            if (!this.streamManager) return { mode: 'static', name: '' };
            return this.streamManager.getTuningState();
        }
        
        startAudio() {
            if (!this.isInitialized) this.init();
            if (!this.isPlaying) {
                this.setupStaticNoise();
                this.audioContext.resume().then(() => {
                    console.log('Audio context resumed, starting static');
                    this.staticSource.start();
                    this.isPlaying = true;
                    console.log('Static started, isPlaying:', this.isPlaying);
                }).catch(error => {
                    console.error('Failed to resume audio context:', error);
                });
            }
        }
        
        updateStreams(position) {
            if (this.streamManager) {
                this.streamManager.update(position);
            }
        }
        
        getCurrentStation() {
            return this.streamManager ? this.streamManager.getCurrentStation() : null;
        }
        
        getDiscoveryProgress() {
            return this.streamManager ? this.streamManager.getDiscoveryProgress() : { discovered: 0, total: 0, current: null };
        }
    }

    class StreamManager {
        constructor() {
            this.stations = [
                {
                    name: "NTS Radio 1",
                    url: "https://stream-relay-geo.ntslive.net/stream",
                    audio: null,
                    gain: null,
                    isBuffering: false,
                    isPlaying: false,
                    isReady: false
                },
                {
                    name: "NTS Radio 2", 
                    url: "https://stream-relay-geo.ntslive.net/stream2",
                    audio: null,
                    gain: null,
                    isBuffering: false,
                    isPlaying: false,
                    isReady: false
                },
                {
                    name: "Resonance FM",
                    url: "https://stream.resonance.fm/resonance",
                    audio: null,
                    gain: null,
                    isBuffering: false,
                    isPlaying: false,
                    isReady: false
                },
                {
                    name: "Radio Sputnik",
                    url: "http://stream.radiosputnik.nl:8002/",
                    audio: null,
                    gain: null,
                    isBuffering: false,
                    isPlaying: false,
                    isReady: false
                },
                {
                    name: "Worldwide FM",
                    url: "https://worldwidefm.out.airtime.pro/worldwidefm_a",
                    audio: null,
                    gain: null,
                    isBuffering: false,
                    isPlaying: false,
                    isReady: false
                },
                {
                    name: "Soho Radio",
                    url: "http://sohoradiomusic.doughunt.co.uk:8000/320mp3",
                    audio: null,
                    gain: null,
                    isBuffering: false,
                    isPlaying: false,
                    isReady: false
                },
                {
                    name: "KCRW",
                    url: "https://streams.kcrw.com/kcrw_mp3",
                    audio: null,
                    gain: null,
                    isBuffering: false,
                    isPlaying: false,
                    isReady: false
                },
                {
                    name: "EHFM",
                    url: "https://ehfm.out.airtime.pro/ehfm_a",
                    audio: null,
                    gain: null,
                    isBuffering: false,
                    isPlaying: false,
                    isReady: false
                },
                {
                    name: "KEXP",
                    url: "https://kexp.streamguys1.com/kexp160.aac",
                    audio: null,
                    gain: null,
                    isBuffering: false,
                    isPlaying: false,
                    isReady: false
                },
                {
                    name: "LYL",
                    url: "https://icecast.lyl.live/live",
                    audio: null,
                    gain: null,
                    isBuffering: false,
                    isPlaying: false,
                    isReady: false
                },
                {
                    name: "Stegi",
                    url: "https://movementathens.out.airtime.pro/movementathens_a?_ga=2.221863196.549192854.1604689934-1315503358.1602963392",
                    audio: null,
                    gain: null,
                    isBuffering: false,
                    isPlaying: false,
                    isReady: false
                },
                {
                    name: "Radio Relativa",
                    url: "https://streamer.radio.co/sd6131729c/listen",
                    audio: null,
                    gain: null,
                    isBuffering: false,
                    isPlaying: false,
                    isReady: false
                },
                {
                    name: "OLA",
                    url: "https://ola-radio.radiocult.fm/stream",
                    audio: null,
                    gain: null,
                    isBuffering: false,
                    isPlaying: false,
                    isReady: false
                },
                {
                    name: "Noods",
                    url: "https://noods-radio.radiocult.fm/stream",
                    audio: null,
                    gain: null,
                    isBuffering: false,
                    isPlaying: false,
                    isReady: false
                },
                {
                    name: "Cashmere",
                    url: "https://cashmereradio.out.airtime.pro/cashmereradio_b",
                    audio: null,
                    gain: null,
                    isBuffering: false,
                    isPlaying: false,
                    isReady: false
                },
                {
                    name: "THF",
                    url: "https://thfradio2.out.airtime.pro/thfradio2_a",
                    audio: null,
                    gain: null,
                    isBuffering: false,
                    isPlaying: false,
                    isReady: false
                },
                {
                    name: "Intergalactic",
                    url: "https://radio.intergalactic.fm/3",
                    audio: null,
                    gain: null,
                    isBuffering: false,
                    isPlaying: false,
                    isReady: false
                },
                {
                    name: "buena vida",
                    url: "https://s4.radio.co/s69b281ac0/low",
                    audio: null,
                    gain: null,
                    isBuffering: false,
                    isPlaying: false,
                    isReady: false
                }
            ];
            
            // Buffer-driven sequential tuning state
            this.audioContext = null;
            this.staticGain = null;
            this.baseStaticVolume = 0.15;
            
            this.currentStation = null;      // Station currently audible (during fade-out too)
            this.currentIndex = -1;
            
            this.targetStation = null;       // Next station being prepared / faded in
            this.targetIndex = 0;
            
            this.state = 'STATIC';           // 'STATIC' | 'FADING_IN' | 'LOCKED' | 'FADING_OUT'
            this.lastRotation = 0;
            this.lastDirection = 1;          // +1 or -1
            this.readyRotation = 0;          // Anchor where target became ready
            this.fadeOutStartRotation = 0;   // Anchor where fade-out of current began
            this.fadeInDirection = 1;        // Direction (+1/-1) when FADING_IN started
            this.fadeOutDirection = 1;       // Direction (+1/-1) when FADING_OUT started
            
            this.fadeInDegrees = 45;         // Degrees of movement to fully fade in after ready
            this.fadeOutDegrees = 45;        // Degrees of movement to fully fade out current

            this.currentFadeInRatio = 0;
            this.currentFadeOutRatio = 0;

            // Lock plateau config
            this.lockWindowDegrees = 60;     // Total window centered at lock where station stays fully clear
            this.lockCenterRotation = 0;
            this.lockedAtMs = 0;
            this.lockedMinMs = 1200;         // Minimum time to stay locked before allowing fade-out
            this.lockExitExtraDegrees = 5;   // Extra deadband degrees beyond half-window to avoid re-lock jitter
        }
        
        init(audioContext, staticGain, masterCompressor, staticFilter) {
            this.audioContext = audioContext;
            this.staticGain = staticGain;
            this.masterCompressor = masterCompressor;
            this.staticFilter = staticFilter;
        }
        
        wrapIndex(i) {
            const n = this.stations.length;
            return ((i % n) + n) % n;
        }

        pickNextIndex(fromIndex, direction) {
            const n = this.stations.length;
            for (let step = 1; step <= n; step++) {
                const idx = this.wrapIndex(fromIndex + direction * step);
                const st = this.stations[idx];
                if (!st || st._failed) continue;
                return idx;
            }
            return this.wrapIndex(fromIndex + direction);
        }
        
        applyGain(gainNode, value, tc = 0.2) {
            if (!gainNode) return;
            try {
                gainNode.gain.setTargetAtTime(value, this.audioContext.currentTime, tc);
            } catch (_) {}
        }
        
        update(position) {
            const delta = position - this.lastRotation;
            if (delta === 0) return;
            const direction = delta > 0 ? 1 : -1;
            const dirChanged = direction !== this.lastDirection;
            this.lastDirection = direction;
            
            // If no target chosen yet, choose one based on current direction
            if (!this.targetStation) {
                if (this.currentIndex < 0) {
                    this.targetIndex = this.wrapIndex(direction > 0 ? 0 : this.stations.length - 1);
                } else {
                    this.targetIndex = this.wrapIndex(this.currentIndex + direction);
                }
                this.targetStation = this.stations[this.targetIndex];
            }
            
            // Always ensure target is buffering
            if (this.targetStation && !this.targetStation.isBuffering && !this.targetStation.isReady) {
                this.startBuffering(this.targetStation);
            }
            
            switch (this.state) {
                case 'STATIC': {
                    // Full static while waiting for readiness
                    this.applyGain(this.staticGain, this.baseStaticVolume, 0.2);

                    // Retarget based on current direction so reversing picks the correct neighbor
                    const desiredIndex = this.wrapIndex(this.currentIndex < 0 ? (direction > 0 ? 0 : this.stations.length - 1) : this.currentIndex + direction);
                    if (this.targetIndex !== desiredIndex) {
                        this.targetIndex = desiredIndex;
                        this.targetStation = this.stations[this.targetIndex];
                    }
                    
                    if (this.targetStation && !this.targetStation.isBuffering && !this.targetStation.isReady) {
                        this.startBuffering(this.targetStation);
                    }
                    
                    this.currentFadeInRatio = 0;
                    this.currentFadeOutRatio = 0;

                    if (this.targetStation && this.targetStation.isReady) {
                        // Anchor fade-in to the moment of readiness
                        this.readyRotation = position;
                        this.fadeInDirection = direction;
                        // Start station playback silent if not yet started
                        if (!this.targetStation.isPlaying) {
                            this.startStation(this.targetStation);
                        }
                        this.state = 'FADING_IN';
                    }
                    break;
                }
                case 'FADING_IN': {
                    if (!this.targetStation) { this.state = 'STATIC'; break; }
                    if (!this.targetStation.isPlaying) this.startStation(this.targetStation);

                    // Ensure only one station audible: if a different current is audible, duck it quickly
                    if (this.currentStation && this.currentStation !== this.targetStation && this.currentStation.gain) {
                        try { this.currentStation.gain.gain.setTargetAtTime(0, this.audioContext.currentTime, 0.08); } catch (_) {}
                    }

                    // If we reversed back before fully locking, and we're moving opposite to fade-in, allow ratio to decrease
                    if (direction !== this.fadeInDirection) {
                        this.readyRotation = Math.min(this.readyRotation, position); // ensure progress reduces when reversing
                        this.fadeInDirection = direction; // switch to new direction for a responsive feel
                    }
                    
                    const progressed = this.fadeInDirection * (position - this.readyRotation);
                    const ratio = Math.max(0, Math.min(1, progressed / this.fadeInDegrees));
                    this.currentFadeInRatio = ratio;
                    this.currentFadeOutRatio = 0;
                    
                    // Crossfade target vs static and open HPF while reducing static highs
                    this.applyGain(this.targetStation.gain, ratio, 0.15);
                    if (this.targetStation.filter) {
                        const startHz = 3000;
                        const endHz = 60;
                        const freq = startHz + (endHz - startHz) * ratio;
                        try { this.targetStation.filter.frequency.setTargetAtTime(freq, this.audioContext.currentTime, 0.2); } catch (_) {}
                    }
                    if (this.staticFilter) {
                        const startLowpass = 6000;
                        const endLowpass = 12000;
                        const lp = startLowpass + (endLowpass - startLowpass) * ratio;
                        try { this.staticFilter.frequency.setTargetAtTime(lp, this.audioContext.currentTime, 0.2); } catch (_) {}
                    }
                    this.applyGain(this.staticGain, this.baseStaticVolume * (1 - ratio), 0.15);
                    
                    if (ratio >= 1) {
                        // Enter LOCKED plateau
                        this.currentStation = this.targetStation;
                        this.currentIndex = this.targetIndex;
                        this.state = 'LOCKED';
                        this.lockCenterRotation = position;
                        this.lockedAtMs = (window.performance && performance.now) ? performance.now() : Date.now();
                        // Select and buffer the next target in background
                        this.targetIndex = this.pickNextIndex(this.currentIndex, direction);
                        this.targetStation = this.stations[this.targetIndex];
                        // Debounce arming next target slightly to avoid rapid re-entry
                        setTimeout(() => {
                            if (!this.targetStation) return;
                            if (!this.targetStation.isBuffering && !this.targetStation.isReady && !this.targetStation._failed) {
                                this.startBuffering(this.targetStation);
                            }
                        }, 200);
                    }
                    break;
                }
                case 'LOCKED': {
                    // Full station, no static
                    if (this.currentStation && this.currentStation.gain) this.applyGain(this.currentStation.gain, 1, 0.1);
                    this.applyGain(this.staticGain, 0, 0.2);
                    if (this.currentStation && this.currentStation.filter) {
                        try { this.currentStation.filter.frequency.setTargetAtTime(60, this.audioContext.currentTime, 0.2); } catch (_) {}
                    }
                    if (this.staticFilter) {
                        try { this.staticFilter.frequency.setTargetAtTime(12000, this.audioContext.currentTime, 0.2); } catch (_) {}
                    }
                    // If direction changed while locked, retarget the neighbor accordingly
                    if (dirChanged) {
                        const desired = this.pickNextIndex(this.currentIndex, direction);
                        if (this.targetIndex !== desired) {
                            this.targetIndex = desired;
                            this.targetStation = this.stations[this.targetIndex];
                            if (!this.targetStation.isBuffering && !this.targetStation.isReady) {
                                this.startBuffering(this.targetStation);
                            }
                        }
                    }
                    // Check if we moved beyond lock window and held minimum time
                    const elapsed = ((window.performance && performance.now) ? performance.now() : Date.now()) - this.lockedAtMs;
                    const movedFromCenter = Math.abs(position - this.lockCenterRotation);
                    if (elapsed >= this.lockedMinMs && movedFromCenter >= (this.lockWindowDegrees / 2 + this.lockExitExtraDegrees)) {
                        this.state = 'FADING_OUT';
                        this.fadeOutStartRotation = position;
                        this.fadeOutDirection = direction;
                        this.currentFadeOutRatio = 0;
                    }
                    break;
                }
                case 'FADING_OUT': {
                    if (!this.currentStation || !this.currentStation.isPlaying) {
                        this.state = 'STATIC';
                        break;
                    }
                    const progressed = this.fadeOutDirection * (position - this.fadeOutStartRotation);
                    const ratio = Math.max(0, Math.min(1, progressed / this.fadeOutDegrees));
                    this.currentFadeOutRatio = ratio;
                    this.currentFadeInRatio = 0;
 
                    // If we reversed at the very start of fade-out, snap back to LOCKED to prevent dual audio
                    if (direction !== this.fadeOutDirection && ratio <= 0) {
                        this.state = 'LOCKED';
                        this.lockCenterRotation = position;
                        this.lockedAtMs = (window.performance && performance.now) ? performance.now() : Date.now();
                        // Retarget neighbor in new direction
                        const desired = this.pickNextIndex(this.currentIndex, direction);
                        this.targetIndex = desired;
                        this.targetStation = this.stations[this.targetIndex];
                        if (!this.targetStation.isBuffering && !this.targetStation.isReady) {
                            this.startBuffering(this.targetStation);
                        }
                        break;
                    }

                    // If we reversed back later in fade-out and near static, retarget appropriately
                    if (direction !== this.fadeOutDirection && ratio < 0.25) {
                        const desired = this.pickNextIndex(this.currentIndex, direction);
                        this.targetIndex = desired;
                        this.targetStation = this.stations[this.targetIndex];
                        if (!this.targetStation.isBuffering && !this.targetStation.isReady) {
                            this.startBuffering(this.targetStation);
                        }
                    }
 
                    // Crossfade current vs static and close HPF while bringing back static highs
                    this.applyGain(this.currentStation.gain, 1 - ratio, 0.15);
                    if (this.currentStation.filter) {
                        const startHz = 60;
                        const endHz = 3000;
                        const freq = startHz + (endHz - startHz) * ratio;
                        try { this.currentStation.filter.frequency.setTargetAtTime(freq, this.audioContext.currentTime, 0.2); } catch (_) {}
                    }
                    if (this.staticFilter) {
                        const startLowpass = 12000;
                        const endLowpass = 6000;
                        const lp = startLowpass + (endLowpass - startLowpass) * ratio;
                        try { this.staticFilter.frequency.setTargetAtTime(lp, this.audioContext.currentTime, 0.2); } catch (_) {}
                    }
                    this.applyGain(this.staticGain, this.baseStaticVolume * ratio, 0.15);
 
                    if (ratio >= 1) {
                        // Current fully faded -> stop it
                        this.stopStation(this.currentStation);
                        this.currentStation = null;
                        // If the next target is ready, start its fade-in on further movement
                        if (this.targetStation && this.targetStation.isReady) {
                            this.state = 'FADING_IN';
                            this.readyRotation = position;
                            this.fadeInDirection = direction;
                            if (!this.targetStation.isPlaying) this.startStation(this.targetStation);
                        } else {
                            this.state = 'STATIC';
                        }
                    }
                    break;
                }
            }
            
            this.lastRotation = position;
        }
        
        getTuningState() {
            // UI state: expose name and phase for text rendering
            if (this.state === 'FADING_IN') {
                return { mode: 'fadingIn', name: this.targetStation ? this.targetStation.name : '' };
            }
            if (this.state === 'LOCKED') {
                return { mode: 'locked', name: this.currentStation ? this.currentStation.name : '' };
            }
            if (this.state === 'FADING_OUT') {
                if (this.currentStation && this.currentStation.isPlaying) {
                    return { mode: 'fadingOut', name: this.currentStation.name };
                }
                return { mode: 'static', name: this.targetStation ? this.targetStation.name : '' };
            }
            return { mode: 'static', name: this.targetStation ? this.targetStation.name : '' };
        }
        
        startBuffering(station) {
            if (!station || station.isBuffering || station.isReady) return;
            
            try {
                station.isBuffering = true;
                station.audio = new Audio();
                station.audio.crossOrigin = 'anonymous';
                station.audio.src = station.url;
                station.audio.load();
                
                let readyTimeout;
                const markReady = () => {
                    if (station.isReady) return;
                    station.isReady = true;
                };
                const onCanPlay = () => {
                    // Wait a short debounce to avoid flicker-ready
                    clearTimeout(readyTimeout);
                    readyTimeout = setTimeout(markReady, 300);
                };
                const onPlaying = () => {
                    clearTimeout(readyTimeout);
                    readyTimeout = setTimeout(markReady, 200);
                };
                station.audio.addEventListener('canplay', onCanPlay, { once: true });
                station.audio.addEventListener('playing', onPlaying, { once: true });
                
                station._loadStartedAt = (window.performance && performance.now) ? performance.now() : Date.now();
                const timeoutMs = 6000; // skip if not ready in 6s
                station._readyTimeoutId = setTimeout(() => {
                    if (!station.isReady) {
                        station.isBuffering = false;
                        station.isReady = false;
                        station._failed = true;
                    }
                }, timeoutMs);

                station.audio.addEventListener('error', () => {
                    station.isBuffering = false;
                    station.isReady = false;
                    station._failed = true;
                }, { once: true });
            } catch (_) {
                station.isBuffering = false;
                station.isReady = false;
            }
        }
        
        startStation(station) {
            if (!station || station.isPlaying) return;
            
            // Ensure only one station is audible at a time
            this.stations.forEach(s => {
                if (s !== station && s.isPlaying && s.gain) {
                    try {
                        s.gain.gain.setTargetAtTime(0, this.audioContext.currentTime, 0.05);
                        if (s.audio) s.audio.pause();
                    } catch (_) {}
                }
            });
            
            // Try Web Audio connection with CORS fallback
            try {
                if (!station._webAudioSource) {
                    station._webAudioSource = this.audioContext.createMediaElementSource(station.audio);
                }
                
                station.gain = this.audioContext.createGain();
                station.gain.gain.value = 0;
                
                // Per-station processing: source -> highpass -> compressor -> gain -> master compressor
                station.filter = this.audioContext.createBiquadFilter();
                station.filter.type = 'highpass';
                station.filter.frequency.setValueAtTime(2000, this.audioContext.currentTime);
                station.filter.Q.value = 0.707;

                station.compressor = this.audioContext.createDynamicsCompressor();
                station.compressor.threshold.setValueAtTime(-18, this.audioContext.currentTime);
                station.compressor.knee.setValueAtTime(12, this.audioContext.currentTime);
                station.compressor.ratio.setValueAtTime(2.5, this.audioContext.currentTime);
                station.compressor.attack.setValueAtTime(0.01, this.audioContext.currentTime);
                station.compressor.release.setValueAtTime(0.3, this.audioContext.currentTime);

                station._webAudioSource.connect(station.filter);
                station.filter.connect(station.compressor);
                station.compressor.connect(station.gain);
                station.gain.connect(this.masterCompressor);
                
                station._noWebAudio = false;
                console.log(`Web Audio connected: ${station.name}`);
                
            } catch (error) {
                console.warn(`Web Audio failed for ${station.name}, falling back to direct audio:`, error);
                
                // CORS fallback - use direct audio volume control
                station._noWebAudio = true;
                station.audio.volume = 0;
                
                // Create a mock gain node that controls audio.volume
                station.gain = {
                    gain: {
                        setTargetAtTime: (value, time, tc) => {
                            // Smooth volume transition using requestAnimationFrame
                            const startVol = station.audio.volume;
                            const targetVol = Math.max(0, Math.min(1, value));
                            const startTime = performance.now();
                            const duration = tc * 1000; // convert to milliseconds
                            
                            const animate = () => {
                                const elapsed = performance.now() - startTime;
                                const progress = Math.min(1, elapsed / duration);
                                const easeOut = 1 - Math.pow(1 - progress, 3); // ease-out cubic
                                station.audio.volume = startVol + (targetVol - startVol) * easeOut;
                                
                                if (progress < 1) {
                                    requestAnimationFrame(animate);
                                }
                            };
                            animate();
                        }
                    }
                };
            }
            
            station.audio.play();
            station.isPlaying = true;
        }
        
        stopStation(station) {
            if (!station) return;
            try {
                if (station.audio) {
                    station.audio.pause();
                    station.audio.src = '';
                    station.audio = null;
                }
                if (station.gain) {
                    station.gain.disconnect();
                    station.gain = null;
                }
                if (station.compressor) {
                    try { station.compressor.disconnect(); } catch (_) {}
                    station.compressor = null;
                }
                if (station.filter) {
                    try { station.filter.disconnect(); } catch (_) {}
                    station.filter = null;
                }
            } catch (_) {}
            station.isBuffering = false;
            station.isPlaying = false;
            station.isReady = false;
        }
        
        getCurrentStation() {
            return this.currentStation || null;
        }
        
        getDiscoveryProgress() {
            const ready = this.stations.filter(s => s.isReady).length;
            return {
                discovered: ready,
                total: this.stations.length,
                current: this.currentStation
            };
        }
    }

    class TextScrambler {
        constructor(element) {
            this.el = element;
            this.chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789     ';
            this.currentText = '';
            this.lastLength = 16;
            this.lastTarget = '';
            this.lastRevealCount = 0;
        }
        render(targetText, clarityRatio, moved) {
            const target = targetText || '';
            const len = Math.max(8, Math.min(24, target.length || this.lastLength || 16));
            const revealCount = target.length ? Math.floor((Math.max(0, Math.min(1, clarityRatio || 0))) * target.length) : 0;
            const shouldUpdate = moved || target !== this.lastTarget || revealCount !== this.lastRevealCount || this.currentText.length !== len;
            if (!shouldUpdate) return;
            let out = '';
            for (let i = 0; i < len; i++) {
                if (i < target.length) {
                    if (i < revealCount) {
                        out += target[i];
                    } else {
                        out += this._randomChar();
                    }
                } else {
                    // pad tail with space or light noise
                    out += ' ';
                }
            }
            if (out !== this.currentText) {
                this.currentText = out;
                this.el.textContent = out;
            }
            this.lastLength = len;
            this.lastTarget = target;
            this.lastRevealCount = revealCount;
        }
        _randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)];
        }
    }

    class RadioKnob {
        constructor() {
            this.knob = document.getElementById('knob');
            this.glassOverlay = document.getElementById('glassOverlay');
            this.status = document.getElementById('status');

            this.driftToggle = document.getElementById('driftToggle');
            this.rotation = 0;
            this.isDragging = false;
            this.startRotation = 0;
            this.startY = 0;
            this.audioEngine = new AudioEngine();
            
            // Initialize prism background
            const prismContainer = document.querySelector('.prism-background');
            console.log('Prism container found:', prismContainer);
            if (prismContainer) {
                console.log('Creating PrismBackground...');
                this.prismBackground = new PrismBackground(prismContainer);
            } else {
                console.error('Prism container not found!');
            }
            this.scrambler = new TextScrambler(this.status);
            this._lastRenderRotation = 0;
            this._lastFrameMs = 0;
            this.driftEnabled = false;
            this.driftSpeedDegPerSec = 12; // steady pace
            this.init();
        }
        
        init() {
            this.bindEvents();
            this.animate();
        }
        
        bindEvents() {
            // Mouse events
            this.knob.addEventListener('mousedown', (e) => {

                this.isDragging = true;
                this.startY = e.clientY;
                this.startRotation = this.rotation;
                this.knob.style.cursor = 'grabbing';
                this.audioEngine.startAudio();
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!this.isDragging) return;
                const deltaY = e.clientY - this.startY;
                this.rotation = this.startRotation + deltaY * 0.1;

                e.preventDefault();
            });
            
            document.addEventListener('mouseup', () => {

                this.isDragging = false;
                this.knob.style.cursor = 'grab';
            });
            
            // Touch events
            this.knob.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    console.log('Touch start - starting audio');
                    this.isDragging = true;
                    this.startY = e.touches[0].clientY;
                    this.startRotation = this.rotation;
                    this.audioEngine.startAudio();
                    e.preventDefault();
                }
            });
            
            document.addEventListener('touchmove', (e) => {
                if (!this.isDragging || e.touches.length !== 1) return;
                const deltaY = e.touches[0].clientY - this.startY;
                this.rotation = this.startRotation + deltaY * 0.1;

                e.preventDefault();
            });
            
            document.addEventListener('touchend', () => {

                this.isDragging = false;
            });

            // Drift toggle
            if (this.driftToggle) {
                this.driftToggle.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (!this.audioEngine.isPlaying) {
                        this.audioEngine.startAudio();
                    }
                    this.driftEnabled = !this.driftEnabled;
                    this.driftToggle.classList.toggle('active', this.driftEnabled);
                });
            }

            // Setup glass refraction overlay
            this._setupGlassOverlay();
        }
        
        animate() {
            const now = performance.now();
            const dt = this._lastFrameMs ? (now - this._lastFrameMs) / 1000 : 0;
            // Auto drift when enabled and not dragging
            if (this.driftEnabled && !this.isDragging && dt > 0) {
                this.rotation += this.driftSpeedDegPerSec * dt;
            }
            this.knob.style.transform = `rotate(${this.rotation}deg)`;
            this.knob.style.setProperty('--angle', `${this.rotation}deg`);

            // update glass overlay frame
            this._renderGlassOverlay();

            
            this.audioEngine.updateStreams(this.rotation);
            
            const tuning = this.audioEngine.getTuningState();
            const moved = Math.abs(this.rotation - this._lastRenderRotation) > 0.1;
            if (!this.audioEngine.isPlaying) {
                this.status.textContent = 'Click to start audio';
            } else {
                // Clarity ratio driven by tuning phase
                let clarity = 0;
                if (tuning.mode === 'fadingIn') clarity = Math.max(0, Math.min(1, this.audioEngine.streamManager.currentFadeInRatio));
                else if (tuning.mode === 'fadingOut') clarity = Math.max(0, 1 - this.audioEngine.streamManager.currentFadeOutRatio);
                else if (tuning.mode === 'locked') clarity = 1; // Fully resolved
                else clarity = 0;

                // Capitalize target and render; in static we hint upcoming name's length but reveal ratio stays 0
                const target = (tuning.name || '').toUpperCase();
                this.scrambler.render(target, clarity, moved);
            }
            
            this._lastRenderRotation = this.rotation;
            this._lastFrameMs = now;
            requestAnimationFrame(this.animate.bind(this));
        }
    }

    // Simple WebGL refraction pass sampling the prism canvas behind
    RadioKnob.prototype._setupGlassOverlay = function() {
        const canvas = this.glassOverlay;
        const prismCanvas = document.querySelector('.prism-background canvas');
        if (!canvas || !prismCanvas) return;
        const gl = canvas.getContext('webgl', { alpha: true, antialias: false });
        if (!gl) return;
        this._glass = { gl, prismCanvas };
        const dpr = Math.min(2, window.devicePixelRatio || 1);
        const resize = () => {
            const r = this.knob.getBoundingClientRect();
            canvas.width = Math.max(1, Math.floor(r.width * dpr));
            canvas.height = Math.max(1, Math.floor(r.height * dpr));
            canvas.style.width = r.width + 'px';
            canvas.style.height = r.height + 'px';
            gl.viewport(0, 0, canvas.width, canvas.height);
        };
        new ResizeObserver(resize).observe(this.knob);
        resize();

        const vs = `
        attribute vec2 a;
        varying vec2 vUv;
        void main(){
            vUv = (a + 1.0) * 0.5;
            gl_Position = vec4(a, 0.0, 1.0);
        }`;
        const fs = `
        precision highp float;
        varying vec2 vUv;
        uniform sampler2D uTex;
        uniform vec2 uOffset; // offset within background texture
        uniform vec2 uScale;  // scale within background texture
        uniform float uAngle;
        // normal-mapped refraction using a simple rotating normal field
        vec2 rotate(vec2 p, float a){
            float c = cos(a), s = sin(a);
            return mat2(c,-s,s,c)*p;
        }
        void main(){
            // build a circular normal from uv to mimic lensing
            vec2 p = vUv * 2.0 - 1.0; // -1..1
            float r = length(p);
            if (r > 1.0) discard; // keep dial circular
            // derive a fake normal that bends inward
            vec2 n = normalize(p + 1e-6);
            n = rotate(n, uAngle);
            float strength = smoothstep(1.0, 0.2, r) * 0.06; // stronger in center
            vec2 offset = n * strength;
            // map overlay uv into background uv space and apply refraction
            vec2 uvBase = uOffset + vUv * uScale;
            vec2 uv = uvBase + offset * uScale;
            uv = clamp(uv, vec2(0.0), vec2(1.0));
            vec3 col = texture2D(uTex, uv).rgb;
            // subtle vignette and highlight
            float v = smoothstep(1.0, 0.6, r);
            col *= 1.0 - v * 0.15;
            gl_FragColor = vec4(col, 0.45);
        }`;
        const compile = (type, src) => {
            const sh = gl.createShader(type);
            gl.shaderSource(sh, src);
            gl.compileShader(sh);
            return sh;
        };
        const prog = gl.createProgram();
        gl.attachShader(prog, compile(gl.VERTEX_SHADER, vs));
        gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fs));
        gl.linkProgram(prog);
        gl.useProgram(prog);
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        const quad = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, quad);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1,-1, 1,-1, -1,1,
            -1,1, 1,-1, 1,1
        ]), gl.STATIC_DRAW);
        const loc = gl.getAttribLocation(prog, 'a');
        gl.enableVertexAttribArray(loc);
        gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);

        // create texture from prism canvas
        const tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        this._glass.tex = tex;
        this._glass.prog = prog;
        this._glass.uTex = gl.getUniformLocation(prog, 'uTex');
        this._glass.uAngle = gl.getUniformLocation(prog, 'uAngle');
        this._glass.uOffset = gl.getUniformLocation(prog, 'uOffset');
        this._glass.uScale = gl.getUniformLocation(prog, 'uScale');
    };

    RadioKnob.prototype._renderGlassOverlay = function() {
        const g = this._glass;
        if (!g) return;
        const { gl, prismCanvas, tex, prog } = g;
        // update texture from the prism canvas
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, prismCanvas);
        gl.useProgram(prog);
        // compute mapping from knob overlay to prism canvas in uv space
        const prismRect = prismCanvas.getBoundingClientRect();
        const knobRect = this.knob.getBoundingClientRect();
        const scaleX = Math.max(1e-5, knobRect.width / prismRect.width);
        const scaleY = Math.max(1e-5, knobRect.height / prismRect.height);
        const offX = (knobRect.left - prismRect.left) / prismRect.width;
        const offYTop = (knobRect.top - prismRect.top) / prismRect.height;
        // convert top-origin to bottom-origin for texture uv space
        const offY = 1.0 - offYTop - scaleY;
        gl.uniform2f(g.uOffset, offX, offY);
        gl.uniform2f(g.uScale, scaleX, scaleY);
        gl.uniform1f(g.uAngle, this.rotation * 0.0174533 * 0.35);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
    };

    function setupStationList() {
        const listEl = document.getElementById('stationList');
        const toggleEl = document.getElementById('stationToggle');
        const panelEl = document.getElementById('stationPanel');
        if (!listEl || !toggleEl || !panelEl) return;
        try {
            const sm = new StreamManager();
            const stationData = {
                'BUENA VIDA': { city: 'glasgow', url: 'https://buenavida.co.uk/' },
                'CASHMERE': { city: 'berlin', url: 'https://cashmereradio.com/' },
                'EHFM': { city: 'edinburgh', url: 'https://www.ehfm.live/' },
                'INTERGALACTIC': { city: 'the hague', url: 'https://www.intergalactic.fm/' },
                'KCRW': { city: 'los angeles', url: 'https://www.kcrw.com/' },
                'KEXP': { city: 'seattle', url: 'https://kexp.org/' },
                'LYL': { city: 'lyon', url: 'https://lyl.live/' },
                'MOTHER EARTH': { city: 'munich', url: 'https://motherearthradio.de/' },
                'NOODS': { city: 'bristol', url: 'https://noodsradio.com/' },
                'NTS RADIO 1': { city: 'london', url: 'https://www.nts.live/' },
                'NTS RADIO 2': { city: 'london', url: 'https://www.nts.live/' },
                'OLA': { city: 'marseille', url: 'https://www.olaradio.fr/' },
                'RADIO RELATIVA': { city: 'madrid', url: 'https://radiorelativa.eu/' },
                'RADIO SPUTNIK': { city: 'holland', url: 'https://radiosputnik.nl/' },
                'RESONANCE FM': { city: 'london', url: 'https://www.resonancefm.com/' },
                'SOHO RADIO': { city: 'london', url: 'https://sohoradio.com/' },
                'STEGI': { city: 'athens', url: 'https://stegi.radio/' },
                'THF': { city: 'berlin', url: 'https://www.thfradio.de/' },
                'WFMU': { city: 'jersey city', url: 'https://wfmu.org/' },
                'WORLDWIDE FM': { city: 'london', url: 'https://worldwidefm.net/' }
            };
            const names = sm.stations.map(s => s.name).filter(Boolean).map(n => n.toUpperCase()).sort((a,b)=>a.localeCompare(b));
            listEl.innerHTML = '';
            const frag = document.createDocumentFragment();
            names.forEach(nameUpper => {
                const li = document.createElement('li');
                const data = stationData[nameUpper];
                if (data) {
                    const link = document.createElement('a');
                    link.href = data.url;
                    link.target = '_blank';
                    link.rel = 'noopener noreferrer';
                    link.textContent = `${nameUpper} - ${data.city}`;
                    link.style.color = 'inherit';
                    link.style.textDecoration = 'none';
                    link.addEventListener('mouseover', () => link.style.textDecoration = 'underline');
                    link.addEventListener('mouseout', () => link.style.textDecoration = 'none');
                    li.appendChild(link);
                } else {
                    li.textContent = nameUpper;
                }
                frag.appendChild(li);
            });
            listEl.appendChild(frag);
        } catch (_) {}
        toggleEl.addEventListener('click', (e) => {
            e.stopPropagation();
            const open = panelEl.classList.toggle('open');
            panelEl.setAttribute('aria-hidden', open ? 'false' : 'true');
            toggleEl.classList.toggle('active', open);
        });
        document.addEventListener('click', (e) => {
            if (!panelEl.classList.contains('open')) return;
            const t = e.target;
            if (!panelEl.contains(t) && t !== toggleEl) {
                panelEl.classList.remove('open');
                panelEl.setAttribute('aria-hidden', 'true');
                toggleEl.classList.remove('active');
            }
        });
    }
    
    document.addEventListener('DOMContentLoaded', () => {
        new RadioKnob();
        setupStationList();
    });
    </script>
</body>
</html> 